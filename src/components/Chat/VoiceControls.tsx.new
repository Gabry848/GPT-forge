import { useState, useEffect, useCallback } from 'react';
import { FaMicrophone, FaMicrophoneSlash, FaVolumeUp, FaVolumeDown, FaCog } from 'react-icons/fa';
import SpeechRecognition, { useSpeechRecognition } from 'react-speech-recognition';
import './VoiceControls.css';

interface VoiceControlsProps {
  onTextReceived: (text: string) => void;
  isTyping: boolean;
  currentMessage: string | null;
}

const VoiceControls: React.FC<VoiceControlsProps> = ({ onTextReceived, isTyping, currentMessage }) => {
  const [isSpeaking, setIsSpeaking] = useState<boolean>(false);
  const [voices, setVoices] = useState<SpeechSynthesisVoice[]>([]);
  const [selectedVoice, setSelectedVoice] = useState<string>('');
  const [showVoiceSettings, setShowVoiceSettings] = useState<boolean>(false);
  const [speechRate, setSpeechRate] = useState<number>(1);
  const [speechPitch, setSpeechPitch] = useState<number>(1);

  // Utilizziamo l'hook useSpeechRecognition da react-speech-recognition
  const { transcript, listening, resetTranscript, browserSupportsSpeechRecognition } = useSpeechRecognition();

  // Inizializzazione delle voci disponibili
  useEffect(() => {
    const loadVoices = () => {
      const availableVoices = window.speechSynthesis.getVoices();
      setVoices(availableVoices);
      
      // Seleziona una voce italiana se disponibile
      const italianVoice = availableVoices.find(voice => voice.lang.includes('it'));
      if (italianVoice) {
        setSelectedVoice(italianVoice.name);
      } else if (availableVoices.length > 0) {
        setSelectedVoice(availableVoices[0].name);
      }
    };
    
    if (window.speechSynthesis) {
      if (window.speechSynthesis.onvoiceschanged !== undefined) {
        window.speechSynthesis.onvoiceschanged = loadVoices;
      }
      loadVoices();
    }
    
    // Pulizia quando il componente viene smontato
    return () => {
      if (window.speechSynthesis) {
        window.speechSynthesis.cancel();
      }
    };
  }, []);

  // Monitora il transcript per inviare il testo quando arriva
  useEffect(() => {
    if (transcript && transcript.trim().length > 0) {
      onTextReceived(transcript);
      // Reset del transcript dopo l'invio
      resetTranscript();
    }
  }, [transcript, onTextReceived, resetTranscript]);

  // Gestisce l'avvio e l'arresto del riconoscimento vocale
  const toggleListening = useCallback(() => {
    if (!browserSupportsSpeechRecognition) {
      alert('Il tuo browser non supporta il riconoscimento vocale.');
      return;
    }
    
    if (listening) {
      SpeechRecognition.stopListening();
    } else {
      SpeechRecognition.startListening({ language: 'it-IT', continuous: true });
    }
  }, [listening, browserSupportsSpeechRecognition]);

  // Funzione per leggere il messaggio corrente
  const speakMessage = useCallback(() => {
    if (!currentMessage || isSpeaking || isTyping) return;
    
    const utterance = new SpeechSynthesisUtterance(currentMessage);
    
    // Trova la voce selezionata
    const voice = voices.find(v => v.name === selectedVoice);
    if (voice) {
      utterance.voice = voice;
    }
    
    utterance.rate = speechRate;
    utterance.pitch = speechPitch;
    
    utterance.onstart = () => setIsSpeaking(true);
    utterance.onend = () => setIsSpeaking(false);
    utterance.onerror = () => setIsSpeaking(false);
    
    window.speechSynthesis.speak(utterance);
  }, [currentMessage, isSpeaking, isTyping, selectedVoice, voices, speechRate, speechPitch]);

  // Ferma la lettura quando è in corso
  const stopSpeaking = useCallback(() => {
    window.speechSynthesis.cancel();
    setIsSpeaking(false);
  }, []);

  // Aggiorna il valore della voce selezionata
  const handleVoiceChange = (e: React.ChangeEvent<HTMLSelectElement>) => {
    setSelectedVoice(e.target.value);
  };

  if (!browserSupportsSpeechRecognition) {
    return (
      <div className="voice-controls">
        <span className="voice-status">Riconoscimento vocale non supportato dal browser</span>
      </div>
    );
  }

  return (
    <div className="voice-controls">
      <button 
        className={`voice-button ${listening ? 'active listening' : ''}`}
        onClick={toggleListening}
        aria-label={listening ? 'Interrompi registrazione' : 'Inizia registrazione'}
      >
        <span className="tooltip">{listening ? 'Interrompi ascolto' : 'Attiva microfono'}</span>
        {listening ? <FaMicrophone size={20} /> : <FaMicrophoneSlash size={20} />}
      </button>
      
      <button 
        className={`voice-button ${isSpeaking ? 'active speaking' : ''}`}
        onClick={isSpeaking ? stopSpeaking : speakMessage}
        disabled={isTyping || !currentMessage}
        aria-label={isSpeaking ? 'Interrompi lettura' : 'Leggi messaggio'}
      >
        <span className="tooltip">{isSpeaking ? 'Interrompi lettura' : 'Leggi messaggio'}</span>
        {isSpeaking ? <FaVolumeUp size={20} /> : <FaVolumeDown size={20} />}
      </button>
      
      <button 
        className="voice-button"
        onClick={() => setShowVoiceSettings(!showVoiceSettings)}
        aria-label="Impostazioni vocali"
      >
        <span className="tooltip">Impostazioni vocali</span>
        <FaCog size={20} />
      </button>
      
      {showVoiceSettings && (
        <div className="voice-settings">
          <label htmlFor="voice-select">Voce:</label>
          <select 
            id="voice-select" 
            value={selectedVoice}
            onChange={handleVoiceChange}
          >
            {voices.map(voice => (
              <option key={voice.name} value={voice.name}>
                {voice.name} ({voice.lang})
              </option>
            ))}
          </select>
          
          <label htmlFor="rate-select">Velocità: {speechRate}x</label>
          <input
            id="rate-select"
            type="range"
            min="0.5"
            max="2"
            step="0.1"
            value={speechRate}
            onChange={(e) => setSpeechRate(parseFloat(e.target.value))}
          />
          
          <label htmlFor="pitch-select">Tono: {speechPitch}</label>
          <input
            id="pitch-select"
            type="range"
            min="0.5"
            max="2"
            step="0.1"
            value={speechPitch}
            onChange={(e) => setSpeechPitch(parseFloat(e.target.value))}
          />
          
          <div className="button-group">
            <button 
              className="voice-settings-button"
              onClick={() => {
                setSpeechRate(1);
                setSpeechPitch(1);
              }}
            >
              Reset
            </button>
            <button 
              className="voice-settings-button"
              onClick={() => setShowVoiceSettings(false)}
            >
              Chiudi
            </button>
          </div>
        </div>
      )}
    </div>
  );
};

export default VoiceControls;
